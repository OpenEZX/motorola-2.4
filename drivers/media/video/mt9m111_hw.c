/*================================================================================
                                                                               
                      Header Name: mt9m111_hw.c

General Description: Camera module mt9m111 interface source file
 
==================================================================================
                     Motorola Confidential Proprietary
                 Advanced Technology and Software Operations
               (c) Copyright Motorola 1999, All Rights Reserved
 
Revision History:
                            Modification     Tracking
Author                 Date          Number     Description of Changes
----------------   ------------    ----------   -------------------------
Ma Zhiqiang         6/30/2004                    Change for auto-detect
Ma Zhiqiang         9/03/2004                    Add the update from Peter 
                                                 (worked out with Micron/Flextronix and LV CTO team)

==================================================================================
                                 INCLUDE FILES
==================================================================================*/
#include <linux/types.h>
#include <asm/mach-types.h>
#include <asm/io.h>
#include <asm/semaphore.h>
#include <asm/hardware.h>
#include <asm/mach-types.h>
#include <asm/dma.h>
#include <asm/irq.h>

#include <linux/types.h>
#include <linux/module.h>
#include <linux/init.h>
#include <linux/wrapper.h>
#include <linux/delay.h>
#include <linux/i2c.h> 

#include "mt9m111_hw.h"
#include "camera.h"

//#define MT9M111_LOG

#ifdef  MT9M111_LOG
#define mt9m111_dbg_print(fmt, args...) dbg_print(fmt, ##args)
#else
#define mt9m111_dbg_print(fmt, args...) ;
#endif

extern int mt9m111_read(u16 addr, u16 *pvalue);
extern int mt9m111_write(u16 addr, u16 value);
 
static u16 outWidth = 320;
static u16 outHeight = 240;
static u16 sensorWidth = 1280;
static u16 sensorHeight = 1024;

static u16 preferredFlickerMask = 0;
static int inSkipMode = 1;
static int didSnapPhoto = 0;
static u16 minFPS = -1;
static u16 maxFPS = -1;

static u8 isHalfSensorSize = 0;

// light tables

#if 0
// table generated by Micron's default calibration

// auto
static u16 autoLight[] =
{  0x00AE, 0x2923, 0x04E4, 0x00B7, 0x009F, 0x0068, 0x00C5, 0x0088,
   0x0027, 0x007A, 0x0088, 0x00AF, 0x00C9, 0x0014, 0x0005, 0x0033,
   0x0031, 0x0004, 0x0052, 0x0057, 0x0091, 0x005B, 0x6345, 0x3E26,
   0x0002 };

// direct sun
static u16 directSun[] =         
{ 0x00AE, 0x2923, 0x0524, 0x00BF, 0x009B, 0x004A, 0x00AC, 0x008A,
  0x0051, 0x004F, 0x007E, 0x0082, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x4458, 0x0000,
  0x0000 };

// incandescent
static u16 incandescentLight[] =
{ 0x00A6, 0x2923, 0x04E4, 0x00A8, 0x0090, 0x007A, 0x00DC, 0x0083,
  0x0004, 0x00A7, 0x00CC, 0x00DB, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x8232, 0x0000,
  0x0000 };

// fluorescent
static u16 tl84Light[] =
{ 0x00A6, 0x2737, 0x04E4, 0x00AF, 0x006F, 0x003C, 0x008B, 0x0097,
  0x000F, 0x00D2, 0x00B5, 0x00DF, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x8630, 0x0000,
  0x0000 };

#endif

#if 1
// no lens cover ccmat -- Satish likes this one

/*
static u16 autoLight[] =
{ 0x00AE, 0x271B, 0x02A4, 0x00E9, 0x0082, 0x006D, 0x007A, 0x009C,
  0x0047, 0x0095, 0x0065, 0x006C, 0x00C9, 0x0010, 0x0007, 0x0027,
  0x001A, 0x0001, 0x004C, 0x0062, 0x0059, 0x0037, 0x6345, 0x3E26,
  0x0002 };
*/
// 
static u16 autoLight[] =
{ 0x00AE, 0x2923, 0x04E4, 0x00C8, 0x00DF, 0x0080, 0x00C2, 0x0084,
  0x001F, 0x006B, 0x007F, 0x00AB, 0x00C9, 0x001F, 0x0002, 0x002F,
  0x0022, 0x000D, 0x005E, 0x002E, 0x007B, 0x0048, 0x604C, 0x3C28,
  0x0002 };

static u16 incandescentLight[] =
{ 0x00AE, 0x2723, 0x02A4, 0x00D8, 0x00EB, 0x0076, 0x0084, 0x0096,
  0x001E, 0x00C5, 0x008D, 0x0085, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x8232, 0x0000,
  0x0000 };

static u16 tl84Light[] =
{ 0x00AE, 0x2723, 0x02A4, 0x00EB, 0x00D6, 0x002C, 0x00A8, 0x00B0,
  0x000E, 0x00F8, 0x0086, 0x008B, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x8630, 0x0000,
  0x0000 };

static u16 d65Light[] =
{ 0x00AE, 0x291B, 0x0524, 0x00EF, 0x0082, 0x0054, 0x00D9, 0x009D,
  0x006E, 0x0064, 0x00E0, 0x00A1, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x4458, 0x0000,
  0x0000 };

#endif

#if 0

// lens cover ccmat -- Satish doesn't like this one

static u16 autoLight[] =
{ 0x00AE, 0x271A, 0x02A4, 0x007E, 0x0081, 0x003A, 0x0082, 0x00BB,
  0x00AD, 0x009B, 0x007D, 0x0079, 0x0099, 0x000C, 0x0025, 0x0011,
  0x0024, 0x0009, 0x001E, 0x007F, 0x0063, 0x003F, 0x6344, 0x3A28,
  0x0002 };

static u16 incandescentLight[] =
{ 0x00AE, 0x2723, 0x02A4, 0x00EF, 0x00DE, 0x0032, 0x0094, 0x00BF,
  0x009E, 0x00DA, 0x00AF, 0x0098, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x8030, 0x0000,
  0x0000 };

static u16 tl84Light[] =
{ 0x00AE, 0x2723, 0x02A4, 0x00E9, 0x00EC, 0x0045, 0x0093, 0x0097,
  0x0001, 0x00DA, 0x0092, 0x008A, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x8630, 0x0000,
  0x0000 };

static u16 d65Light[] =
{ 0x00AE, 0x291A, 0x04E4, 0x0082, 0x0092, 0x0042, 0x00DD, 0x00B4,
  0x00B9, 0x005A, 0x0096, 0x00B0, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x4658, 0x0000,
  0x0000 };

#endif


/*****************************************************************************
*
*****************************************************************************/
static void mt9m111_reset(void)
{
    minFPS = -1;
    maxFPS = -1;
    inSkipMode = 1;
    didSnapPhoto = 0;
    isHalfSensorSize = 0;
}

/*****************************************************************************
*									     *
*        I2C Management		 					     *
*									     *
*****************************************************************************/
u16 mt9m111_reg_read(u16 reg_addr)
{
    u16 value=0;
    mt9m111_read(reg_addr, &value);
    return value;
}

void mt9m111_reg_write(u16 reg_addr, u16 reg_value)
{
    mt9m111_write(reg_addr, reg_value);
}

/////////////////////////////////////////////////////////////////////////////////////
//   
//  Programming Guide : Configuration Methods 
//
/////////////////////////////////////////////////////////////////////////////////////

int mt9m111_get_device_id(u16 *id)
{
    /*Device ID is in register 0x0 */
    *id = mt9m111_reg_read(0x0);
    mt9m111_dbg_print("mt9m111 device ID is 0x%x", *id);       

    return MICRON_ERR_NONE;
}

static int mt9m111_update_size(int context)
{
    mt9m111_dbg_print("mt9m111_update_size, sensor=%dx%d, out=%dx%d", sensorWidth, sensorHeight, outWidth, outHeight);

    /* set the sensor size */ 
    if(context == 0)
    {
        //context A
        mt9m111_write(0x1A6, sensorWidth);
        mt9m111_write(0x1A9, sensorHeight);
    }
    else
    {
        //context B
        mt9m111_write(0x1A0, sensorWidth);
        mt9m111_write(0x1A3, sensorHeight);
    }
    /* set output size */
    if(outWidth > sensorWidth)
    {
        outWidth = sensorWidth;
    }
    if(outHeight > sensorHeight)
    {
        outHeight = sensorHeight;
    }

    if(context == 0)
    {
        //context A
        mt9m111_write(0x1A7, outWidth);
        mt9m111_write(0x1AA, outHeight);
    }
    else
    {
        //context B
        mt9m111_write(0x1A1, outWidth);
        mt9m111_write(0x1A4, outHeight);
    }

    return MICRON_ERR_NONE;
}

int mt9m111_viewfinder_on()
{
    mt9m111_dbg_print("mt9m111_viewfinder_on, sensor=%dx%d, out=%dx%d", sensorWidth, sensorHeight, outWidth, outHeight);

    if((outWidth*2 > sensorWidth) || (outHeight*2 > sensorHeight))
    {
        mt9m111_dbg_print("mt9m111_viewfinder_on: making sure skip mode is off");

	// make sure skip mode is off

	    if (inSkipMode || didSnapPhoto)
	    {
            mt9m111_dbg_print("mt9m111_viewfinder_on: skip mode is on -- turning in off");
	    //
	    // set to full power, turn off subsampling
	    //     switch to context B for read mode, full frame, and max line delay
 	    //

    	    mt9m111_write(0x2D2, 0x0041);	// turn off subsampling and turn on full power mode
    	    mt9m111_write(0x2CC, 0x4);		// Context Ctl Program Select -- use default program
    	    u16 v = mt9m111_reg_read(0x2CB);	// read Context Ctl Program Advance
    	    mt9m111_write(0x2CB, v|1);		// advance program

    	    didSnapPhoto = 0;
	        inSkipMode = 0;

            //
            // after program advance, we need to poll Global Context Ctl to wait for 
            // sensor read mode context has switched to context B
            //

	        int count = 0;
	        while ((mt9m111_reg_read(0x00C8) != 0x000B) && (++count < 20))
	        {
	            mdelay(10);
            }
        }

    	mt9m111_update_size(0);
    }
    else
    {
    	mt9m111_update_size(0);

	// make sure skip mode is on

        mt9m111_dbg_print("mt9m111_viewfinder_on: making sure skip mode is on");

	    if (!inSkipMode || didSnapPhoto)
	    { 
            mt9m111_dbg_print("mt9m111_viewfinder_on: skip mode is off -- turning in on");

	    //
	    // set to low power, turn on subsampling
            //     switch to context A for read mode, full frame, and max line delay

    	    mt9m111_write(0x2D2, 0x0000);	// turn off subsampling and turn on full power mode
    	    mt9m111_write(0x2CC, 0x4);		// Context Ctl Program Select -- use default program
    	    u16 v = mt9m111_reg_read(0x2CB);	// read Context Ctl Program Advance
    	    mt9m111_write(0x2CB, v|1);		// advance program

	        inSkipMode = 1;
    	    didSnapPhoto = 0;
	    }
    }

    return MICRON_ERR_NONE;
}

int mt9m111_viewfinder_off()
{
    mt9m111_dbg_print("mt9m111_viewfinder_off");
    return MICRON_ERR_NONE;
}

int mt9m111_snapshot_trigger()
{
    mt9m111_dbg_print("mt9m111_snapshot_trigger");

    mt9m111_update_size(1);

    mt9m111_write(0x2D2, 0x007F);		// Context return to default => all in context B
    mt9m111_write(0x2CC, 0x0004);		// Program Select = default => run program to default
    u16 v = mt9m111_reg_read(0x2CB);		
    mt9m111_write(0x2CB, v | 1);	        // Program Advance = RUN/GO

    didSnapPhoto = 1;

    return MICRON_ERR_NONE;
}

int mt9m111_snapshot_complete()
{
    mt9m111_dbg_print("mt9m111_snapshot_complete");
    return MICRON_ERR_NONE;
}

int mt9m111_input_size(micron_window_size * window)
{
    sensorWidth = window->width;
    sensorHeight = window->height;

    mt9m111_dbg_print("mt9m111_input_size, sensor=%dx%d", sensorWidth, sensorHeight);
    return MICRON_ERR_NONE;
}

int mt9m111_output_size(micron_window_size * window)
{
    outWidth = window->width;
    outHeight = window->height;

    mt9m111_dbg_print("mt9m111_output_size, out=%dx%d", outWidth, outHeight);
    return MICRON_ERR_NONE;
}

int mt9m111_get_input_size( micron_window_size * window)
{
    window->width = mt9m111_reg_read(0x1A6);
    window->height = mt9m111_reg_read(0x1A9);

    return MICRON_ERR_NONE;
}

int mt9m111_set_fps(u16 newMaxFPS, u16 newMinFPS)
{
    mt9m111_dbg_print("mt9m111_set_fps: newMaxFPS=%d, newMinFPS=%d", newMaxFPS, newMinFPS);

    //
    // clamp newMaxFPS to a legal range
    //

    const int MIN_FPS = 5;
    const int MAX_FPS = 15;

    newMaxFPS = (newMaxFPS > MAX_FPS) ? MAX_FPS : newMaxFPS;
    newMaxFPS = (newMaxFPS < MIN_FPS) ? MIN_FPS : newMaxFPS;

    mt9m111_dbg_print("mt9m111_set_fps: newMaxFPS=%d, newMinFPS=%d", newMaxFPS, newMinFPS);

    //
    // if the maxFPS has changed, update the vblank
    //

    if (newMaxFPS != maxFPS)
    {

        //
        // enforce max fps by setting the vertical blanking
        //
        // The table below assumes:
        //    MCLK = 24.375 MHz
        //    target line time = 127 micro seconds
        //    HBLANK in low power = ???
        //    HBLANK in full power = ???
        //
        // The following values came from Micron during a site visit on 9/1.
        //
        // If the input clock changes, these settings also need to change.
        //
        // The basic idea is that a flicker-detection friendly framerate close
        // to the requested frame rate is chosen.
        //

        const u16 vblanksLowPower[] = 
        { 
            1021,	/* 5.11   */ 
            701, 	/* 6.45   */
            556, 	/* 7.32   */ 
            412, 	/* 8.45   */
            309, 	/* 9.5    */
            233, 	/* 10.45  */
            162, 	/* 11.55  */
            123, 	/* 12.25  */
            90, 	/* 12.91  */
            50, 	/* 13.81  */
            18   	/* 14.645 */
        };

        const u16 vblanksFullPower[] = 
        { 
            509, 	/* 5.11 */  
            189, 	/* 6.45 */  
            44, 	/* 7.32 */ 
            44, 	/* 7.32 */  
            44, 	/* 7.32 */ 
            44, 	/* 7.32 */
            44, 	/* 7.32 */
            44, 	/* 7.32 */ 
            44, 	/* 7.32 */ 
            44, 	/* 7.32 */ 
            44 		/* 7.32 */
        };

        //
        // use the following hblanks to achieve a line rate of 127us
        //

        const u16 readModeLowPower = 0x040C;
        const u16 readModeFullPower = 0x0300;
        const u16 hblankLowPower = 126;
        const u16 hblankFullPower = 260;
        const u16 aeLineSizeLowPower = 1548;
        const u16 aeLineSizeFullPower = 1548;
        const u16 aeShutterDelayLimitLowPower = 1548;
        const u16 aeShutterDelayLimitFullPower = 1548;
        const u16 aeFlickerFullFrameTime60HzLowPower = 262;
        const u16 aeFlickerFullFrameTime60HzFullPower = 262;
        const u16 aeFlickerFullFrameTime50HzLowPower = 314;
        const u16 aeFlickerFullFrameTime50HzFullPower = 314;
        const u16 flickerSearchRange50HZ = 0x1712;
        const u16 flickerSearchRange60HZ = 0x120D;
        // const u16 flickerParameter = 0x1E1C; // 7/8 trials
        const u16 flickerParameter = 0x0D1C; 	// 3/4 trials

        mt9m111_write(0x005, hblankFullPower);
        mt9m111_write(0x006, vblanksFullPower[newMaxFPS-5]);
        mt9m111_write(0x007, hblankLowPower);
        mt9m111_write(0x008, vblanksLowPower[newMaxFPS-5]);
        mt9m111_write(0x020, readModeFullPower);
        mt9m111_write(0x021, readModeLowPower);
        mt9m111_write(0x239, aeLineSizeLowPower);
        mt9m111_write(0x23A, aeLineSizeFullPower);
        mt9m111_write(0x23B, aeShutterDelayLimitLowPower);
        mt9m111_write(0x23C, aeShutterDelayLimitFullPower);
        mt9m111_write(0x257, aeFlickerFullFrameTime60HzLowPower);
        mt9m111_write(0x258, aeFlickerFullFrameTime50HzLowPower);
        mt9m111_write(0x259, aeFlickerFullFrameTime60HzFullPower);
        mt9m111_write(0x25A, aeFlickerFullFrameTime50HzFullPower);
        mt9m111_write(0x25C, flickerSearchRange60HZ);
        mt9m111_write(0x25D, flickerSearchRange50HZ);
        mt9m111_write(0x264, flickerParameter);
 
        maxFPS = newMaxFPS;
    }

    return MICRON_ERR_NONE;

}

int mt9m111_set_autoexposure_zone(u16 newMinFPS)
{
    const int MIN_FPS = 5;
    const int MAX_FPS = 15;

    //
    // This driver only implements two minimum framerates: 5fps and 15fps.
    //
    // The mt9m111 can support every min fps between 5fps and 15fps, but the AE settings 
    // will become very complex.
    // 

    if (newMinFPS > 5)
    {
        newMinFPS = MAX_FPS;
    }
    else
    {
        newMinFPS = MIN_FPS;
    }

    //
    // if the minFPS has changed, update the AE limit
    //

    if (newMinFPS != minFPS)
    {
        //
        // enforce min fps by setting max exposure time
        //

        if (newMinFPS == 5)
        {
            // set min fps to 5 fps -> AE Zone 24
            u16 limitAE = ((120/5) << 5) & 0x03E0;
            mt9m111_write(0x237, limitAE);

            //
            // work-around for AE strangeness
            // symptom: start in dark, preview gets darker, darker, very dark, black, then is OK.
            //

            if (mt9m111_reg_read(0x23F) == 8)
            {
                u16 v;
                v = mt9m111_reg_read(0x22E);	// read target luma register

                // by setting target luma to 0, trick AE into zone <= 8
                mt9m111_write(0x22E, 0x0000);	// set target luma to 0

                //
                // wait until AE zone is in bounds (or time exceeds 1500ms)
                //
                // 1500ms is a long time!
                //

                int count=0;
                while ((mt9m111_reg_read(0x23F) == 8) && (++count < 30))
                {
                    mdelay(50);
                }

                mt9m111_write(0x22E, v);	// rewrite target luma register
            }
        }
        else
        {
            // set min fps to 15 fps -> AE Zone 8
            u16 limitAE = ((120/15) << 5) & 0x03E0;
            mt9m111_write(0x237, limitAE);
            mt9m111_dbg_print("AE zone limit is %0x\n", limitAE);

            //
            // work-around for AE strangeness
            // symptom: start in dark, preview gets darker, darker, very dark, black, then is OK.
            //

            if (mt9m111_reg_read(0x23F) > 8)
            {
                u16 v;
                v = mt9m111_reg_read(0x22E);	// read target luma register

                // by setting target luma to 0, trick AE into zone <= 8
                mt9m111_write(0x22E, 0x0000);	// set target luma to 0

                //
                // wait until AE zone is in bounds (or time exceeds 1500ms)
                //
                // 1500ms is a long time!
                //

                int count=0;
                while ((mt9m111_reg_read(0x23F) > 8) && (++count < 30))
                {
                    mdelay(50);
                }

                mt9m111_write(0x22E, v);	// rewrite target luma register
            }
        }

        minFPS = newMinFPS;
    }

    return MICRON_ERR_NONE;
    
}

int mt9m111_output_format(u16 format)
{
    u16 value;

    if(format == O_FORMAT_422_YCbYCr)
    {
        mt9m111_write(0x13A, 0);
    }
    else
    {
        value = (1<<8)|((format-1)<<6);
        mt9m111_write(0x13A, value);
    }
    return MICRON_ERR_NONE;
}

void mt9m111_dump_register(u16 startRegAddr, u16 endRegAddr, u16* buffer)
{
    u16 addr,value;
	
    for(addr = startRegAddr; addr <= endRegAddr; addr++)
    {
        unsigned long flags;
        local_irq_save(flags);
	   
        mt9m111_read(addr, &value);
	  
        local_irq_restore(flags);

        mt9m111_dbg_print("mt9m111 register: 0x%04x = %04x",addr,value);
	   
        if(buffer)
        {
            *buffer = value;
            buffer++;
        }
    }
}

//
// TODO: make this an IOCTL that is called by the application some time after set_flicker() is
// called
//

int mt9m111_set_flicker_2(void)
{
    mt9m111_dbg_print("mt9m111_set_flicker_2: %04x", preferredFlickerMask);

    int count=0;

    //
    // read flicker_control_1 until it verifies that flicker is set to the preferred rate.
    //

    while(((mt9m111_reg_read(0x25B) & 0x8000) != preferredFlickerMask) && (++count < 50))
    {
        mdelay(20);
    }

    mt9m111_write(0x25B, 0x0002);	// back to auto mode

    return MICRON_ERR_NONE;
}

int mt9m111_set_flicker(int flicker)
{
    mt9m111_dbg_print("mt9m111_set_flicker: %d", flicker);

    preferredFlickerMask = (flicker == 50) ? 0x0000 : 0x8000;

    if (flicker == 50)
    {
        mt9m111_write(0x25B, 0x0001);	// manual mode 50Hz
    }
    else if (flicker == 60)
    {
        mt9m111_write(0x25B, 0x0003);	// manual mode 60Hz
    }
    else
    { 
        return MICRON_ERR_PARAMETER;
    }

    mt9m111_set_flicker_2();

    return MICRON_ERR_NONE;
}

int mt9m111_set_contrast(int contrast)
{
    mt9m111_dbg_print("mt9m111_set_contrast: %d (skipped)", contrast);
    return MICRON_ERR_NONE;

#if 0
    //
    // we don't support setting the contrast in the initial release of A780
    //

    const u16 gammaTable[] = 
    {
        //0x3B2C,0x664D,0x9F87,0xC3B3,0xE0D2, //0.40
        //0x3224,0x664D,0x9F87,0xC3B3,0xE0D2, //0.45
        0x2A1D,0x543B,0x9277,0xBDA9,0xE0CF, //0.50
        0x2318,0x4C34,0x8C70,0xBAA4,0xE0CD, //0.55
        0x1E14,0x462E,0x876A,0xB7A0,0xE0CC, //0.60
        0x1910,0x3F28,0x8163,0xB39B,0xE0CA, //0.65
        0x150D,0x3923,0x7B5D,0xB097,0xE0C9, //0.70
        0x120A,0x341E,0x7657,0xAE93,0xE0C7, //0.75
        0x0F08,0x2F1B,0x7152,0xAB8F,0xE0C6, //0.80
        0x0D07,0x2A17,0x6D4D,0xA88B,0xE0C4, //0.85
        0x0B05,0x2614,0x6848,0xA587,0xE0C2, //0.90
        //0x0804,0x2010,0x6040,0xA080,0xE0C0, //1.00
        //0x0502,0x1A0C,0x5838,0x9A79,0xE0BD, //1.10
        //0x0401,0x1509,0x5131,0x9572,0xE0BA, //1.20
    };

    if(contrast < -4 || contrast > 4)
    {
        return MICRON_ERR_PARAMETER;
    }

    u16 i, regA=0x153, regB=0x1DC;

    for(i=0; i<5; i++)
    {
        mt9m111_write(regA++, gammaTable[(contrast+4)*5+i]);
        mt9m111_write(regB++, gammaTable[(contrast+4)*5+i]);
    } 

    return MICRON_ERR_NONE;
#endif

}

/*set picture style(normal/black white/sepia/solarize/neg.art)*/
int mt9m111_set_style(V4l_PIC_STYLE style)
{
    mt9m111_dbg_print("mt9m111_set_style: %d", style);

  switch(style)
  {
  case V4l_STYLE_BLACK_WHITE:
       mt9m111_write(0x1E2,0x7001);
       break;
  case V4l_STYLE_SEPIA:
       mt9m111_write(0x1E2,0x7002);
       mt9m111_write(0x1E3,0xB023);
       break;
  case V4l_STYLE_SOLARIZE:
       mt9m111_write(0x1E2,0x7004);
       break;
  case V4l_STYLE_NEG_ART:
       mt9m111_write(0x1E2,0x7003);
       break;
  default:
       mt9m111_write(0x1E2,0x7000);
       break;
  }

  return MICRON_ERR_NONE;
}

        
/*set picture light(auto/direct sun/incandescent/fluorescent)*/     
int mt9m111_set_light(V4l_PIC_WB light)
{ 
    u16 *m;
    u16 v;

    switch(light)
    {
        case V4l_WB_DIRECT_SUN:

            mt9m111_dbg_print("mt9m111_set_light: %d (direct sun)", light);
            m = d65Light;
            break;       

        case V4l_WB_INCANDESCENT:

            mt9m111_dbg_print("mt9m111_set_light: %d (incandescent)", light);
            m = incandescentLight;
            break;       

        case V4l_WB_FLUORESCENT:

            mt9m111_dbg_print("mt9m111_set_light: %d (fluorescent)", light);
            m = tl84Light;
            break;

        default:
    
            mt9m111_dbg_print("mt9m111_set_light: %d (default)", light);
            m = autoLight;
            break;

    }

    mt9m111_write(0x202, m[0]);  //BASE_MATRIX_SIGNS
    mt9m111_write(0x203, m[1]);  //BASE_MATRIX_SCALE_K1_K5
    mt9m111_write(0x204, m[2]);  //BASE_MATRIX_SCALE_K6_K9

    mt9m111_write(0x209, m[3]);  //BASE_MATRIX_COEF_K1
    mt9m111_write(0x20A, m[4]);  //BASE_MATRIX_COEF_K2
    mt9m111_write(0x20B, m[5]);  //BASE_MATRIX_COEF_K3
    mt9m111_write(0x20C, m[6]);  //BASE_MATRIX_COEF_K4
    mt9m111_write(0x20D, m[7]);  //BASE_MATRIX_COEF_K5
    mt9m111_write(0x20E, m[8]);  //BASE_MATRIX_COEF_K6
    mt9m111_write(0x20F, m[9]);  //BASE_MATRIX_COEF_K7
    mt9m111_write(0x210, m[10]); //BASE_MATRIX_COEF_K8
    mt9m111_write(0x211, m[11]); //BASE_MATRIX_COEF_K9
    mt9m111_write(0x215, m[12]); //DELTA_COEF_SIGNS
    mt9m111_write(0x216, m[13]); //DELTA_MATRIX_COEF_D1
    mt9m111_write(0x217, m[14]); //DELTA_MATRIX_COEF_D2
    mt9m111_write(0x218, m[15]); //DELTA_MATRIX_COEF_D3
    mt9m111_write(0x219, m[16]); //DELTA_MATRIX_COEF_D4
    mt9m111_write(0x21A, m[17]); //DELTA_MATRIX_COEF_D5
    mt9m111_write(0x21B, m[18]); //DELTA_MATRIX_COEF_D6
    mt9m111_write(0x21C, m[19]); //DELTA_MATRIX_COEF_D7
    mt9m111_write(0x21D, m[20]); //DELTA_MATRIX_COEF_D8
    mt9m111_write(0x21E, m[21]); //DELTA_MATRIX_COEF_D9

    mt9m111_write(0x25E, m[22]); //RATIO_BASE_REG
    mt9m111_write(0x25F, m[23]); //RATIO_DELTA_REG
    mt9m111_write(0x260, m[24]); //SIGNS_DELTA_REG

    //Toggle Manual White Balance to force loading the new table
    v = mt9m111_reg_read(0x106);
    mt9m111_write(0x106, v|0x8000); // Operating Mode Control -- P.13 708E 
    mdelay(200);		    // TODO: correct amount of time? 
    mt9m111_write(0x106, v&~0x8000);

    return MICRON_ERR_NONE;
}

    
/*set picture brightness*/
int mt9m111_set_bright(int bright)
{
    mt9m111_dbg_print("mt9m111_set_bright (gamma) %d", bright);

    const u16 target[] = 
    { 
        37,      // -2.0 EV
        44,      // -1.5 EV
        52,      // -1.0 EV
        62,      // -0.5 EV
        74,      //  0.0 EV
        88,      // +0.5 EV
        105,     // +1.0 EV
        124,     // +1.5 EV
        148      // +2.0 EV
    };

    if(bright < -4 || bright > 4)
    {
        return MICRON_ERR_PARAMETER;
    }

    /*set luma value of AE target*/
    mt9m111_write(0x22E, 0x0C00 + target[bright+4]);
    return MICRON_ERR_NONE;
}


int mt9m111_default_settings()
{
    mt9m111_dbg_print("mt9m111_default_settings");

    mt9m111_reset();

    // Soft Reset -- Reset both sensor AND SOC (and leave sensor digital logic enabled)

    mt9m111_write(0x00D, 0x29);   // Reset sensor and SOC -- P.54
    // i2c will delay enough here for reset to finish (1us is enough)
    mt9m111_write(0x00D, 0x08);   // Release reset -- P.54

    mt9m111_write(0x285, 0x0061);   // AE Gain table 
    mt9m111_write(0x286, 0x0080);   // AE Gain table
    mt9m111_write(0x287, 0x0061);   // AE Gain table
    mt9m111_write(0x288, 0x0061);   // AE Gain table
    mt9m111_write(0x289, 0x03E2);   // AE Gain table
    mt9m111_write(0x238, 0x0840);   // Shutter priority transition zone

    //Enable flicker detection
    mt9m111_write(0x106, 0x708E);   // Operating Mode Control -- P.13 0x0708C

    // Enable 2D defect correction in both contexts 
    mt9m111_write(0x14C, 0x0001);   // Defect Buffer Context A -- P.13 0x0000 -- Enable 2D defect correct context A 
    mt9m111_write(0x14D, 0x0001);   // Defect Buffer Context B -- P.13 0x0000 -- Enable 2D defect correct context B 
    
    // Set centered origin 
    mt9m111_write(0x1a8, 0x4000);   // Reducer YPan A -- P.14 0x0000 -- Cntxt A Y Crop centering 
    mt9m111_write(0x1a5, 0x4000);   // Reducer XPan A -- P.14 0x0000 -- Cntxt A X Crop centering 
    mt9m111_write(0x1a2, 0x4000);   // Reducer YPan B -- P.14 0x0000 -- Cntxt B Y Crop centering 
    mt9m111_write(0x19F, 0x4000);   // Reducer XPan B -- P.14 0x0000 -- Cntxt B X Crop centering 

    // Sensor is running in semi auto mode only 
    mt9m111_write(0x2CC, 0x0004);   // Context Ctl Pgm Select -- P.19 0x0000 

    //mt9m111_write(0x034, 0xC039);   // Reserved -- P.54 0xC019 in es3 -- turn on eclipse

    // Do not invert the pixel clock
    mt9m111_write(0x13A, 0x0000);   // Output Format Control 2A -- P.13 0x0000 
    mt9m111_write(0x19B, 0x0000);   // Output Format Control 2B -- P.14 0x0000

    //Auto sharpening
    mt9m111_write(0x105, 0x000B);   // Aperature Correction (sharpening) gain -- 0x0003 
				    // 75% sharpening, auto-sharpening on

    //Enable classic interpolation at full res
    mt9m111_write(0x1AF, 0x0018);   // Reducer Zoom Control -- P.14 0x0010
    
    //AWB settings for 12mm lens, no ulens shift
    mt9m111_write(0x222, 0xb070);   // Red Gain AWB Limits -- P.16 0x0D960 -- overconstrained currently? (sunburned->0x8870)
    mt9m111_write(0x223, 0xb070);   // Blue Gain AWB Limits -- P.16 0x0D960 -- overconstrained currently?
    mt9m111_write(0x229, 0x847C);   // Reserved -- P.16 0x8D73 -- Thresholds (tied into digital gains above)

    //mt9m111_set_light(V4l_WB_AUTO); //the app will call ioctl to set light

    // lens correction for Micron es3 + flex module 9/31

    mt9m111_write(0x180, 0x0003);    // LENS_ADJ_PARAM_0_5
    mt9m111_write(0x181, 0xC813);    // LENS_ADJ_VERT_RED_0
    mt9m111_write(0x182, 0xEEE2);    // LENS_ADJ_VERT_RED_1_2
    mt9m111_write(0x183, 0xFDF9);    // LENS_ADJ_VERT_RED_3_4
    mt9m111_write(0x184, 0xE10C);    // LENS_ADJ_VERT_GREEN_0
    mt9m111_write(0x185, 0xF0E9);    // LENS_ADJ_VERT_GREEN_1_2
    mt9m111_write(0x186, 0xFFF8);    // LENS_ADJ_VERT_GREEN_3_4
    mt9m111_write(0x187, 0xE60A);    // LENS_ADJ_VERT_BLUE_0
    mt9m111_write(0x188, 0xF2EB);    // LENS_ADJ_VERT_BLUE_1_2
    mt9m111_write(0x189, 0x01F9);    // LENS_ADJ_VERT_BLUE_3_4
    mt9m111_write(0x18A, 0xAE25);    // LENS_ADJ_HORIZ_RED_0
    mt9m111_write(0x18B, 0xDACE);    // LENS_ADJ_HORIZ_RED_1_2
    mt9m111_write(0x18C, 0xF5EF);    // LENS_ADJ_HORIZ_RED_3_4
    mt9m111_write(0x18D, 0x00FD);    // LENS_ADJ_HORIZ_RED_5
    mt9m111_write(0x18E, 0xDE18);    // LENS_ADJ_HORIZ_GREEN_0
    mt9m111_write(0x18F, 0xE5E2);    // LENS_ADJ_HORIZ_GREEN_1_2
    mt9m111_write(0x190, 0xF7F2);    // LENS_ADJ_HORIZ_GREEN_3_4
    mt9m111_write(0x191, 0x00FE);    // LENS_ADJ_HORIZ_GREEN_5
    mt9m111_write(0x192, 0xCF17);    // LENS_ADJ_HORIZ_BLUE_0
    mt9m111_write(0x193, 0xEAE4);    // LENS_ADJ_HORIZ_BLUE_1_2
    mt9m111_write(0x194, 0xF8F4);    // LENS_ADJ_HORIZ_BLUE_3_4
    mt9m111_write(0x195, 0x00FF);    // LENS_ADJ_HORIZ_BLUE_5
    mt9m111_write(0x1B6, 0x1104);    // LENS_ADJ_VERT_RED_5_6
    mt9m111_write(0x1B7, 0x3420);    // LENS_ADJ_VERT_RED_7_8
    mt9m111_write(0x1B8, 0x0503);    // LENS_ADJ_VERT_GREEN_5_6
    mt9m111_write(0x1B9, 0x1C0F);    // LENS_ADJ_VERT_GREEN_7_8
    mt9m111_write(0x1BA, 0x0502);    // LENS_ADJ_VERT_BLUE_5_6
    mt9m111_write(0x1BB, 0x1B0C);    // LENS_ADJ_VERT_BLUE_7_8
    mt9m111_write(0x1BC, 0x0F03);    // LENS_ADJ_HORIZ_RED_6_7
    mt9m111_write(0x1BD, 0x2E1C);    // LENS_ADJ_HORIZ_RED_8_9
    mt9m111_write(0x1BE, 0x0050);    // LENS_ADJ_HORIZ_RED_10
    mt9m111_write(0x1BF, 0x0A02);    // LENS_ADJ_HORIZ_GREEN_6_7
    mt9m111_write(0x1C0, 0x1C13);    // LENS_ADJ_HORIZ_GREEN_8_9
    mt9m111_write(0x1C1, 0x0023);    // LENS_ADJ_HORIZ_GREEN_10
    mt9m111_write(0x1C2, 0x0801);    // LENS_ADJ_HORIZ_BLUE_6_7
    mt9m111_write(0x1C3, 0x1B0F);    // LENS_ADJ_HORIZ_BLUE_8_9
    mt9m111_write(0x1C4, 0x0027);    // LENS_ADJ_HORIZ_BLUE_10
    
    //turn on lens correction
    mt9m111_write(0x106, 0x748E);   // Operating Mode Control -- P.13 0x708E 

    // set luma offset and clip for both contexts
    mt9m111_write(0x134, 0x0000);   // Luma offset (Brightness Offset)
    mt9m111_write(0x135, 0xFF01);   // Luma clip (Brightness Offset)
    // TODO: why FF01, why not FF00?

    // load hard-coded 0.6 gamma table (Context A)
    mt9m111_write(0x153, 0x2217);
    mt9m111_write(0x154, 0x4F34);
    mt9m111_write(0x155, 0x9978);
    mt9m111_write(0x156, 0xD0B6);
    mt9m111_write(0x157, 0xFEE8);
    mt9m111_write(0x158, 0x0000);

    // load hard-coded 0.6 gamma table (Context B)
    mt9m111_write(0x1DC, 0x2217);
    mt9m111_write(0x1DD, 0x4F34);
    mt9m111_write(0x1DE, 0x9978);
    mt9m111_write(0x1DF, 0xD0B6);
    mt9m111_write(0x1E0, 0xFEE8);
    mt9m111_write(0x1E1, 0x0000);

    // add new setting from Kenta's email, Nov.2, 2004
    mt9m111_write(0x21F, 0x0090);
    //mt9m111_write(0x222, 0xb070);     // aleady write above
    //mt9m111_write(0x223, 0xb070);     // aleady write above
    mt9m111_write(0x228, 0xef14);

    return MICRON_ERR_NONE;
}

